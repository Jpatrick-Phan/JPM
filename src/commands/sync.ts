import { cli } from '../cli/ui';
import { fileSystem } from '../utils/files';
import { logger } from '../utils/logger';
import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import fs from 'fs/promises';

const execAsync = promisify(exec);

export async function commandSync() {
    cli.showInfo('Step 4: SYNC', 'Syncing to GitHub...');

    // 1. Check if gh is installed
    try {
        await execAsync('gh --version');
    } catch (e) {
        throw new Error('GitHub CLI (gh) is not installed or not in PATH. Please install it first.');
    }

    // 2. Check if inside a git repo
    try {
        await execAsync('git rev-parse --is-inside-work-tree');
    } catch (e) {
        throw new Error('Not a git repository. Please run "git init" first.');
    }

    // 3. Find latest tasks
    const tasksDir = path.join(process.cwd(), '.jpm/storage/tasks');
    try {
        const files = await fs.readdir(tasksDir);
        const taskFiles = files.filter(f => f.startsWith('task-') && f.endsWith('.md'));

        if (taskFiles.length === 0) {
            cli.showError('No Tasks', 'No tasks found to sync.');
            return;
        }

        cli.startSpinner('Processing local tasks...');

        // Group tasks by "Feature" (assuming simple filename convention or just grouped for now)
        // For professional behavior, we create ONE Parent Issue for the batch of tasks.
        // In a real app, we'd group by the Architecture/Epic ID.
        // For now, let's create a "JPM Sync: [Timestamp]" parent issue.

        const timestamp = new Date().toISOString().split('T')[0];
        const parentTitle = `[Epic] Implementation Plan - ${timestamp}`;
        let parentBody = `## Project Implementation Plan\n\nGenerated by JPM.\n\n### Task List\n`;

        // We need to read all tasks to get titles
        const taskDetails = [];
        for (const file of taskFiles) {
            const content = await fileSystem.readFileSafe(path.join(tasksDir, file));
            // Extract title
            const titleMatch = content.match(/title:\s*(.*)/);
            const title = titleMatch ? titleMatch[1] : file;
            taskDetails.push({ file, title });

            // Add to check list
            parentBody += `- [ ] ${title} <!-- id:${file} -->\n`;
        }

        cli.stopSpinner(true, `Found ${taskFiles.length} tasks ready to sync.`);

        // 4. Create Parent Issue via GH CLI
        const confirmed = await cli.confirm(`Create GitHub Issue "${parentTitle}" with ${taskFiles.length} sub-tasks?`);
        if (!confirmed) return;

        cli.startSpinner('Creating GitHub Issue...');

        // Write temporary body file (gh requires file for multiline)
        const bodyFile = path.join(process.cwd(), '.jpm_cache/gh_body.md');
        await fs.mkdir(path.dirname(bodyFile), { recursive: true });
        await fs.writeFile(bodyFile, parentBody);

        const command = `gh issue create --title "${parentTitle}" --body-file "${bodyFile}"`;
        const { stdout } = await execAsync(command);
        const issueUrl = stdout.trim();

        cli.stopSpinner(true, 'Synced Successfully!');
        cli.showInfo('GitHub Issue', issueUrl);

        // Cleanup
        await fs.unlink(bodyFile);

    } catch (error: any) {
        cli.stopSpinner(false, 'Sync failed');
        throw error;
    }
}
