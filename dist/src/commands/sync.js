"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.commandSync = commandSync;
const ui_1 = require("../cli/ui");
const files_1 = require("../utils/files");
const child_process_1 = require("child_process");
const util_1 = require("util");
const path_1 = __importDefault(require("path"));
const promises_1 = __importDefault(require("fs/promises"));
const execAsync = (0, util_1.promisify)(child_process_1.exec);
async function commandSync() {
    ui_1.cli.showInfo('Step 4: SYNC', 'Syncing to GitHub...');
    // 1. Check if gh is installed
    try {
        await execAsync('gh --version');
    }
    catch (e) {
        throw new Error('GitHub CLI (gh) is not installed or not in PATH. Please install it first.');
    }
    // 2. Check if inside a git repo
    try {
        await execAsync('git rev-parse --is-inside-work-tree');
    }
    catch (e) {
        throw new Error('Not a git repository. Please run "git init" first.');
    }
    // 3. Find latest tasks
    const tasksDir = path_1.default.join(process.cwd(), '.jpm/storage/tasks');
    try {
        const files = await promises_1.default.readdir(tasksDir);
        const taskFiles = files.filter((f) => f.startsWith('task-') && f.endsWith('.md'));
        if (taskFiles.length === 0) {
            ui_1.cli.showError('No Tasks', 'No tasks found to sync.');
            return;
        }
        ui_1.cli.startSpinner('Processing local tasks...');
        // Group tasks by "Feature" (assuming simple filename convention or just grouped for now)
        // For professional behavior, we create ONE Parent Issue for the batch of tasks.
        // In a real app, we'd group by the Architecture/Epic ID.
        // For now, let's create a "JPM Sync: [Timestamp]" parent issue.
        const timestamp = new Date().toISOString().split('T')[0];
        const parentTitle = `[Epic] Implementation Plan - ${timestamp}`;
        let parentBody = `## Project Implementation Plan\n\nGenerated by JPM.\n\n### Task List\n`;
        // We need to read all tasks to get titles
        const taskDetails = [];
        for (const file of taskFiles) {
            const content = await files_1.fileSystem.readFileSafe(path_1.default.join(tasksDir, file));
            // Extract title
            const titleMatch = content.match(/title:\s*(.*)/);
            const title = titleMatch ? titleMatch[1] : file;
            taskDetails.push({ file, title });
            // Add to check list
            parentBody += `- [ ] ${title} <!-- id:${file} -->\n`;
        }
        ui_1.cli.stopSpinner(true, `Found ${taskFiles.length} tasks ready to sync.`);
        // 4. Create Parent Issue via GH CLI
        const confirmed = await ui_1.cli.confirm(`Create GitHub Issue "${parentTitle}" with ${taskFiles.length} sub-tasks?`);
        if (!confirmed)
            return;
        ui_1.cli.startSpinner('Creating GitHub Issue...');
        // Write temporary body file (gh requires file for multiline)
        const bodyFile = path_1.default.join(process.cwd(), '.jpm_cache/gh_body.md');
        await promises_1.default.mkdir(path_1.default.dirname(bodyFile), { recursive: true });
        await promises_1.default.writeFile(bodyFile, parentBody);
        const command = `gh issue create --title "${parentTitle}" --body-file "${bodyFile}"`;
        const { stdout } = await execAsync(command);
        const issueUrl = stdout.trim();
        ui_1.cli.stopSpinner(true, 'Synced Successfully!');
        ui_1.cli.showInfo('GitHub Issue', issueUrl);
        // Cleanup
        await promises_1.default.unlink(bodyFile);
    }
    catch (error) {
        ui_1.cli.stopSpinner(false, 'Sync failed');
        throw error;
    }
}
